# Media Query
```css
/* CSS */
@media (condition) {
  /* Some CSS that'll run if the condition is met. */
}
```
JS의 분기와 비슷함. condition에 어떤 조건이 들어갈 것인지가 관건. 당연히 `font-size`와 같은 요소에는 미디어 쿼리가 적용되지 않는다.

보통 4분기 또는 3분기를 기본 적용하는 것으로 알고 있음.

- 4개의 반응형 분기점 
  - 낮은 해상도의 PC, 태블릿 가로 : ~1024px `(min-width:1024px)`
  - 태블릿 가로 : 768px ~ 1023px `(min-width:768px) and (max-width: 1023px)`
  - 모바일 가로, 태블릿 : 480px ~ 767px `(min-width:480px) and (max-width:767px)`
  - 모바일 : ~480px `(max-width:480px)`
  

- 3개의 반응형 분기점 
  - PC : 1024px ~ `(min-width:1024px)`
  - 태블릿 가로, 세로 : 768px ~ 1023px `(min-width:768px) and (min-width:1023px)`
  - 모바일 가로, 세로 : ~767px `(min-width:767px)`

> 헷갈리는 부분을 짚고 넘어가자면, `min-width`, `max-width`는 모두 **이상**과 **이하**다. **초과**나 **미만**이 아님. 따라서 위의 예시와 같이 실제로 작업을 할 때 픽셀이 겹치지 않도록 지정해야 한다. 


# Selector
여기서 재미있는 부분은 사실 CSS는 선택자 조합이 관건인데, 최근에는 이 선택자 조합을 툴에 의존하기 때문에 중요성이 줄어들고 있음. 어차피 컴파일 되기 때문에 선택자를 이용한 것과 다름없음.

### Pseudo-classes
JS로 이 기능을 구현하기 위해서는 별도로 이벤트 리스너 등을 달아야 한다. CSS로 구현하는 경우 일이 훨씬 쉬워짐.

### Pseudo-elements
:: 이렇게 표기하고 특정 대상이 아니라 대상의 하위 elements를 대상으로 한다. 즉 특정 대상의 상태값 변화에 대응하는 것보다 특정 대상의 하위 요소(더 디테일한 부분)에 접근할 수 있음. 그 중에서도 DOM을 제어하여 명시적으로 만들어주지 않은 elements를 대상으로 함.

### before and after
이게 가장 중요했음. 앞뒤에 뭔가를 추가한다고 보면 된다.
```css
<p>
  This paragraph has little arrows!
</p>
```
```css
<p>
  <span class="pseudo-pseudo">→ </span>
    This paragraph has little arrows!
  <span class="pseudo-pseudo"> ←</span>
</p>
```
첫 번째 html에 befor, after를 더하면 아래 html과 동일한 표현을 할 수 있다. 하지만 의미를 표현할 수는 없기 때문에 표현하고자 하는 대상이 완전히 장식적인 경우. 예를 들어 이미 버튼임이 명확한 상태일 때 어떤 모양을 더하고자 하는 경우에 유용하다.


### Combinators
선택자를 결합하는 경우.
```css
nav a {
}
```
위와 같이 사용하는 경우 실제 `nav`와 `a` 사이에 몇 가지 계층이 더 있더라도 관계없이 작동한다. 
```css
nav > a {
}
```
위와 같이 표현하는 경우 직접적인 child에 적용된다. 


# Units
가장 많이 사용되는 유닛은 픽셀임. 기본적으로 화면에 보이는 것과 일치하기 때문에 좋음. 대부분 픽셀을 쓰는데 가장 큰 예외는 타이포그래피다. 예외?

### Ems
`em`은 재밌는 요소인데, 현재 요소의 폰트 사이즈와 같은 상대적인 단위다. heading의 폰트 사이즈가 24px이고 하단 padding이 2em이라면, 이 padding은 48px일 것이라고 예측할 수 있다. 자식요소에도 영향을 미친다. 이건 좋을 수도 있고 좋지 않을 수도 있음. 자식 요소에도 영향을 미치기 때문에 일괄 변경이 가능하지만 디테일한 교정에 불리하다. 

### Rems
em과 rem의 차이는 어떤 것이 기준인가에 있다. em의 기준이 현재 요소의 폰트 크기라면, rem의 기준은 html 태그에 있다. 따라서 기본 html의 폰트 크기는 16px이기 때문에 기본 1rem 역시 16px이다. DOM 트리의 어느 위치에서든 rem은 일관적이다. 

> 주의할 점은 html 태그의 폰트 사이즈를 px 단위로 바꾸면 안된다는 것이다. 
> 이유는 이렇게 하면 유저의 기본값까지 오버라이드 하게 되기 떄문임. 어떤 사용자는 시력이 좋지 않아서 기본 픽셀의 사이즈를 키우고 싶을 수도 있는데 이것을 원천 차단하게 되기 때문에 접근성 측면에서 아주 불리하다. 물론 해상도를 키울 수 있기 때문에 완전히 불가능한 것은 아니지만 rem, em 단위를 사용할 때 선택지가 더 늘어나기 때문에 권장된다.

```css
html {
  font-size: 1.2em;
}
```
이런식으로 em을 사용하거나 rem을 사용하는 것이 좋다. 

 
### 언제 어떤 단위를 사용해야 하나?
- 타이포그래피는 접근성이 중요하기 때문에 rem을 사용한다.
- 상자 모델과 관련된 속성은 px을 사용한다. rem보다 직관적이고 확실하며 접근성이라는 이점을 취해야 하는 상황도 아니다.
- 너비/높이의 경우 요소의 크기를 고정할지, 가변적으로 지정할지에 따라 다르다. 하나의 div는 250p로 고정하고, 다른 하나는 가용한 영역의 50%만 사용하고 싶은 경우.
- 하나의 속성을 글꼴 크기로 직접 조정하기를 원하는 경우 드물지만 em을 사용한다.


# Typography
스타일링 텍스트의 기본

### Font families
```css
font-family: Arial;
```
몇가지 웹 세이프 폰트가 있다. 이건 메이저 os에 미리 설치된 폰트들이다. Arial, Times New Roman, Tahoma 등이 있다.
사용자 지정 폰트의 경우 우리가 미리 설치해서 사용해야 함. 

웹 폰트를 사용할 때는 따옴표로 묶는 것이 관례이다. 여러 개의 글꼴을 나열할 수 있는데, 첫 번째에 있을수록 우선순위가 높음.

### Bold Text
`font-weight`의 경우 lignt/thin, normal, heavy/bold가 각각 300, 400, 700에 매핑된다.
1부터 1000까지 사용 가능함. 

`strong` 태그의 경우 그저 글꼴을 굵게 만드는 것이 아님. 조금 더 의미론적인 것이다.


### Underlined text
--

### Alignment
--

### Text transforms
텍스트 변환 속성을 이용해서 텍스트를 변경할 수 있음.
```css
/* RENDER WITH ALL CAPS */
text-transform: uppercase;
/* Capitalize The First Letter Of Every Word */
text-transform: capitalize;
```
원본을 변경하면 되는데, 왜 텍스트를 css로 변경하는가? 그건 원본을 보존하기 위해서다. 
HTML을 변경했다면 돌이키기 힘들다. 하지만 이 모든 것을 CSS로 제어한 것이라면 그냥 CSS만 변경하면 된다고!

### Spacing
글자 간격을 변경하는 방법은 두 가지다. `letter-spacing`과 `line-height`임.
`line-height`는 단위가 없음. 비율로 작동하기 때문이다. 즉 2는 1보다 2배 높다. 다른 요소가 1로 정의되었을 때 어떤 요소를 2로 정의하면 그 요소보다 2배 높은 것임. 원래 이 속성의 기본값은 1이었는데 크롬에서는 1.15이고 파이어폭스에서는 1.2다. 

> 선 높이에 대해서는 pretty generous 한 값을 주는 것이 좋다. 저시력자 혹은 인식이 어려운 유저의 접근성 향상을 위해서.

가능하면 선 높이는 px로 지정하지 말자. 

> 재미있는 것은 JSX를 사용하는 경우임. 보통 객체로 인라인 스타일 값을 넘겨주는데 이 때 단위를 쓰지 않는다. 왜냐하면... 리액트가 해주기 때문임. 그러나 `line-height`에 대해서는 단위를 쓰지 않는 것이 좋음. 왜냐면... ratio니까. 이것을 고려해야 한다.


# Debugging in the Browser